"use strict";(self.webpackChunkatlas_site=self.webpackChunkatlas_site||[]).push([[3983],{6372:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>m,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"metodos/temporal_toolkit","title":"temporal_toolkit","description":"Extrapolaci\xf3n (consolidado y deduplicado)","source":"@site/docs/metodos/temporal_toolkit.md","sourceDirName":"metodos","slug":"/metodos/temporal_toolkit","permalink":"/atlas-site/docs/metodos/temporal_toolkit","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Notebooks & refactor \u2014 estructura, modularizaci\xf3n y contratos","permalink":"/atlas-site/docs/metodos/notebooks_estructura_refactor"},"next":{"title":"Cat\xe1logo","permalink":"/atlas-site/docs/category/cat\xe1logo"}}');var i=s(4848),a=s(8453);const d={},o=void 0,t={},l=[{value:"Extrapolaci\xf3n (consolidado y deduplicado)",id:"extrapolaci\xf3n-consolidado-y-deduplicado",level:2},{value:"API de referencia",id:"api-de-referencia",level:3},{value:"QA m\xednimo",id:"qa-m\xednimo",level:3},{value:"Errores t\xedpicos (y c\xf3mo evitarlos)",id:"errores-t\xedpicos-y-c\xf3mo-evitarlos",level:3},{value:"Anclas (0138 &quot;headers only&quot;)",id:"anclas-0138-headers-only",level:3}];function c(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"extrapolaci\xf3n-consolidado-y-deduplicado",children:"Extrapolaci\xf3n (consolidado y deduplicado)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Decisi\xf3n operativa"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Extrapolar ",(0,i.jsx)(n.strong,{children:"cada serie de forma independiente"})," desde su ",(0,i.jsx)(n.strong,{children:"\xfaltima fecha v\xe1lida"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Integrar al ",(0,i.jsx)(n.code,{children:"DataFrame"})," maestro por ",(0,i.jsx)(n.strong,{children:"\xedndice temporal"})," (no por columnas) usando ",(0,i.jsx)(n.code,{children:"combine_first"}),"/",(0,i.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cero NaN bleed"}),": extrapolar una columna ",(0,i.jsx)(n.strong,{children:"no"})," debe introducir ",(0,i.jsx)(n.code,{children:"NaN"})," en las dem\xe1s."]}),"\n",(0,i.jsxs)(n.li,{children:["Dos m\xe9todos habilitados:","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"linear"})," \u2014 regresi\xf3n lineal sobre las ",(0,i.jsxs)(n.strong,{children:["\xfaltimas ",(0,i.jsx)(n.code,{children:"k"})," observaciones"]})," (nivel o tendencia)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"trend_plus_seasonal_median"})," \u2014 extrapola ",(0,i.jsx)(n.strong,{children:"tendencia"})," y le suma el ",(0,i.jsx)(n.strong,{children:"perfil estacional"})," por ",(0,i.jsx)(n.strong,{children:"mediana mensual de residuales"})," ",(0,i.jsx)(n.code,{children:"original - trend"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Contrato m\xednimo"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Entrada"}),": ",(0,i.jsx)(n.code,{children:"df"})," con ",(0,i.jsx)(n.code,{children:"DatetimeIndex"})," ",(0,i.jsx)(n.strong,{children:"mensual"})," (",(0,i.jsx)(n.code,{children:"freq='MS'"}),") llamado ",(0,i.jsx)(n.code,{children:"indice_tiempo"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Par\xe1metros"}),": ",(0,i.jsx)(n.code,{children:"n_months"})," (horizonte, por defecto 6), ",(0,i.jsx)(n.code,{children:"last_k"})," (ventana, por defecto 4)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Salida"}),": series nuevas indexadas en las fechas futuras; integraci\xf3n no destructiva al ",(0,i.jsx)(n.code,{children:"df"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Guardas"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Si hay menos de ",(0,i.jsx)(n.code,{children:"last_k"})," puntos no nulos \u2192 devolver ",(0,i.jsx)(n.code,{children:"NaN"})," en el horizonte y loggear advertencia."]}),"\n",(0,i.jsxs)(n.li,{children:["Si el \xedndice no es mensual \u2192 ",(0,i.jsx)(n.strong,{children:"fallar"})," con mensaje o adaptar expl\xedcitamente antes."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"api-de-referencia",children:"API de referencia"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from __future__ import annotations\nimport numpy as np, pandas as pd\nfrom sklearn.linear_model import LinearRegression\n\n# ---------- utilidades ----------\ndef _assert_monthly_index(df: pd.DataFrame):\n    if not isinstance(df.index, pd.DatetimeIndex):\n        raise ValueError("Se espera DatetimeIndex en df.index")\n    # toleramos freq missing, pero validamos mensualidad por diferencias\n    diffs = df.index.to_series().diff().dropna().value_counts().index\n    if len(diffs) and not any(pd.Timedelta(days=27) <= d <= pd.Timedelta(days=32) for d in diffs):\n        raise ValueError("\xcdndice no parece mensual; adapte antes de extrapolar")\n\ndef _future_index(last_date: pd.Timestamp, n_months: int) -> pd.DatetimeIndex:\n    start = (last_date + pd.offsets.MonthBegin(1)).normalize()\n    return pd.date_range(start, periods=n_months, freq="MS", name="indice_tiempo")\n\n# ---------- m\xe9todo 1: lineal ----------\ndef extrapolate_linear(df: pd.DataFrame, column: str, n_months: int = 6, last_k: int = 4) -> pd.Series:\n    _assert_monthly_index(df)\n    s = df[column].dropna().tail(last_k)\n    fidx = _future_index(df.index.max(), n_months) if s.empty else _future_index(s.index.max(), n_months)\n    if len(s) < last_k:\n        return pd.Series([np.nan] * n_months, index=fidx, name=column)\n    X = np.arange(len(s)).reshape(-1, 1)\n    y = s.values\n    model = LinearRegression().fit(X, y)\n    yhat = model.predict(np.arange(len(s), len(s) + n_months).reshape(-1, 1))\n    return pd.Series(yhat, index=fidx, name=column)\n\n# ---------- m\xe9todo 2: tendencia + mediana mensual de residuales ----------\ndef extrapolate_trend_plus_seasonal_median(\n    df: pd.DataFrame,\n    column_trend: str,\n    column_original: str,\n    n_months: int = 6,\n    last_k: int = 4,\n) -> pd.Series:\n    _assert_monthly_index(df)\n    t = df[column_trend].dropna().tail(last_k)\n    fidx = _future_index(df.index.max(), n_months) if t.empty else _future_index(t.index.max(), n_months)\n    if len(t) < last_k:\n        return pd.Series([np.nan] * n_months, index=fidx, name=column_trend)\n    # extrapolaci\xf3n lineal de la tendencia\n    X = np.arange(len(t)).reshape(-1, 1)\n    y = t.values\n    fore_trend = LinearRegression().fit(X, y).predict(\n        np.arange(len(t), len(t) + n_months).reshape(-1, 1)\n    )\n    # perfil estacional robusto: mediana mensual de (original - tendencia)\n    resid = (df[column_original] - df[column_trend]).copy()\n    monthly_med = resid.groupby(df.index.month).median()\n    adj = monthly_med.reindex(fidx.month).to_numpy()\n    return pd.Series(fore_trend + adj, index=fidx, name=column_trend)\n\n# ---------- integraci\xf3n segura (sin NaN bleed) ----------\ndef extend_df_with_forecasts(\n    df: pd.DataFrame,\n    spec: dict,\n    n_months: int = 6,\n    last_k: int = 4,\n) -> pd.DataFrame:\n    """\n    spec:\n      {\'IPC\':\'linear\',\n       \'EMAE_trend\':(\'trend_plus_seasonal_median\',\'EMAE_trend\',\'EMAE_original\')}\n    Integra predicciones por \xedndice temporal usando combine_first.\n    """\n    if df.index.name != "indice_tiempo":\n        df = df.set_index("indice_tiempo")\n    for col, method in spec.items():\n        if isinstance(method, str) and method == "linear":\n            fore = extrapolate_linear(df, col, n_months=n_months, last_k=last_k)\n            df = df.combine_first(fore.to_frame())\n        elif isinstance(method, tuple) and method[0] == "trend_plus_seasonal_median":\n            _, col_trend, col_orig = method\n            fore = extrapolate_trend_plus_seasonal_median(\n                df, col_trend, col_orig, n_months=n_months, last_k=last_k\n            )\n            df = df.combine_first(fore.to_frame())\n        else:\n            raise ValueError(f"Especificaci\xf3n de m\xe9todo inv\xe1lida para \'{col}\': {method}")\n    return df\n'})}),"\n",(0,i.jsx)(n.h3,{id:"qa-m\xednimo",children:"QA m\xednimo"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No-NaN bleed"}),": para columnas ",(0,i.jsx)(n.strong,{children:"no extrapoladas"}),", ",(0,i.jsx)(n.code,{children:"na_counts"})," antes/despu\xe9s debe coincidir."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Primer punto futuro"})," = ",(0,i.jsx)(n.code,{children:"last_valid_date(col) + 1M"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Horizonte exacto"}),": ",(0,i.jsx)(n.code,{children:"len(future_index) == n_months"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Determinismo"}),": mismos insumos \u21d2 mismo resultado (no hay aleatoriedad)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logs"}),": advertir si ",(0,i.jsx)(n.code,{children:"len(no_nulos) < last_k"})," (se devuelven ",(0,i.jsx)(n.code,{children:"NaN"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"errores-t\xedpicos-y-c\xf3mo-evitarlos",children:"Errores t\xedpicos (y c\xf3mo evitarlos)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concatenar columnas"})," y crear filas huecas \u2192 siempre integrar por \xedndice (",(0,i.jsx)(n.code,{children:"combine_first"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Parchear lista ",(0,i.jsx)(n.code,{children:"interpolate"}),"/stops sin validar \xedndice mensual"]})," \u2192 validar frecuencia antes; adaptar a mensual previamente."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usar medias en vez de medianas"})," para el patr\xf3n mensual \u2192 mayor sensibilidad a outliers; mantener ",(0,i.jsx)(n.strong,{children:"medianas"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"anclas-0138-headers-only",children:'Anclas (0138 "headers only")'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#prep-extract"})," \u2014 extracci\xf3n/limpieza previa a extrapolaci\xf3n."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#json-export"})," \u2014 export de resultados (ver ",(0,i.jsx)(n.em,{children:"metodos/etl_json_policies"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#merge-post"})," \u2014 merge posterior con otras tablas/series por \xedndice temporal."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>o});var r=s(6540);const i={},a=r.createContext(i);function d(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);